/////////////////////////////////////////////////////////////////
////////////////////////Thinking in react////////////////////////
/////////////////////////////////////////////////////////////////

1. Thinking in react
 - Статическое react-приложение
 - Важности про state
 - Определение что есть state
 - Определение где state должен жить
 - Добавление инвертированного потока данных

/////////////////////////////////////////////////////////////////
////////////////Статическое react-приложение/////////////////////
/////////////////////////////////////////////////////////////////

1. Обвести все области/подобласти в макете по принципам единой ответственности и применяя декомпозицию

2. Дать всем областям имена
- FilterableProductTable: включает весь пример
- SearchBar: поле ввода
- ProductTable: отображает таблицу с данными
- ProductCategoryRow: отображает заголовок для каждой категории
- ProductRow: отображает запись с данными

3. Составить иерархический список всех компонентов, состоящих из областей
- FilterableProductTable
--- SearchBar
--- ProductTable
------ ProductCategoryRow
------ ProductRow

4. Написать статическую версию реакт приложения 
- компоненты должны содержать только метод render()
- верхний родительский компонент получит модель данных в качестве свойства (props)
- если внести изменения в базовую модель данных и вызвать ReactDOM.render() заново - UI обновится
- React - предоставляет однопоточный процесс обновления данных

5. Отличия props от state
props - способ передачи ранных от родительского компонента в дочерний
state - зарезервирован для интерактивности - для данных, которые меняются с течением времени
Если ты не используешь что-то в render(), то этого не должно быть в state
https://facebook.github.io/react/docs/state-and-lifecycle.html

6. Способы построения
top-down - Сверху вниз - начать с разработки компонента всего приложения - для простых приложений
bottom-up - Снизу вверх - начать с компонентов, которые находятся внутри родительского компонента - для сложных приложений

7. Способы обновления UI
- ReactDOM.render()
function tick() {
  ReactDOM.render(
    <Element />,
    document.getElementById('root')
  );
}
setInterval(tick, 1000);

- this.setState({})


/////////////////////////////////////////////////////////////////
////////////////////Важности про state///////////////////////////
/////////////////////////////////////////////////////////////////
- Нельзя модифицировать state явно
// Wrong
this.state.comment = 'Hello';
// Correct
this.setState({comment: 'Hello'});

- Обновление state может быть асинхронным, для этого нужно передать в setState() функцию:
this.setState(function(prevState, props) {
  return {
    counter: prevState.counter + props.increment
  };
});

- все state смерживаются

- state недоступен для других компонентов
Компонент может решить передать его state в дочерний компонент как props
<h2>It is {this.state.date}.</h2>
<FormattedDate date={this.state.date} />
Дочерний компонент получит данные в props и не узнает state это или props своего родителя
Это называется "top-down" или "unidirectional" data flow.
Любой state всегда пренадлежит определенному компоненту, и любые данные или UI могут влиять только на компоненты "ниже" их в дереве.
Если представить дерево компонентов как водопад из props, то каждый state компонента это как дополнительный источник воды присоединяемый в произвольной точке, но всегда текущий вниз.

Чтобы продемонстрировать, что все компоненты полностью изолированы, создадим компонент, который рендерит 3 компонента <Clock>

function App() {
  return (
    <div>
      <Clock />
      <Clock />
      <Clock />
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

Каждый <Clock> создает свой таймер и обновляется независимо.

В React-компоентах от того, является ли компонент state-зависимым или state-независимым, определяется реализация деталей компонента, которые могут обновляться с течением времени.

Можно использовать state-зависимые компоненты внутри state-независимых и наоборот

/////////////////////////////////////////////////////////////////
///////////////////Определение что есть state////////////////////
/////////////////////////////////////////////////////////////////
Определим какие данные должны хнаниться в state, а какие в props
Для этого нужно ответить на 3 вопроса:
- Данные переданы от родителя через props? Если да - это возможно не state.
- Данные остаются неизменными с течением времени? Если да - это возможно не state.
- Данные можно вычислить на основе других state или props вашего компонента? Если да - это не state.

- Исходный список продуктов передан в props, поэтому это не state
- Текст в форме ввода и checkbox выглядят как state, т.к. они обновляются с течением времени и не могул быть вычислены ниоткуда.
- И наконец отфильтрованный список продуктов не state, потому что он может быть вычислен из исходного списка продуктов и текста в форме ввода и checkbox.

Итак state:
- search text
- значение checkbox'а

/////////////////////////////////////////////////////////////////
/////////////Определение где state должен жить///////////////////
/////////////////////////////////////////////////////////////////
Теперь определимся какой компонент мутирует, а какой владеет state

Для каждого параметра state в приложении
- Определим все компоненты, которые отображают данные основанные на state
- Найдем общего родителя - один единственный общий компонент выше всех компонентов в иерархии, которые требуют state 
- Этот компонени или компонент выше этого должен быть владельцем state
- Если не можете найти компонент, в котором есть смысл хранить state, просто создайте новый компонент только для хранения state и поместите его куда-нибудь выше по иерархии.

ИТАК:
- ProductTable должен фильтровать список продуктов основанный на state, а SearchBar должен отображать search text and checked state.
- Их общий владелец - FilterableProductTable
- Это концептуально осмысленно поместить state для filter text и checked value в FilterableProductTable


/////////////////////////////////////////////////////////////////
///////////Добавление инвертированного потока данных/////////////
/////////////////////////////////////////////////////////////////
Теперь самое время добавить поддержку потока данных по другим маршрутам: из формы ввода в таблицу продуктов

React делает это явно, чтобы упорстить понимание как работает программа, но накладывает немного больше программирования в отличае от традиционной двусторонней привязки данных.

React игнорирует ввод в поле input чтобы мы вручную устанавливали значение input, чтобы оно всегда соответствовало state переданному в него из FilterableProductTable.

Что бы ни ввел пользователь мы обновляем state чтобы отобразить ввод пользователя.

Как только компоненты обновят их state, FilterableProductTable передаст callback в SearchBar, который сработает, когда state будет обновлен.

Мы можем использовать событие onChange у input для этого и callback переданный из FilterableProductTable вызовет setState() и приложение обновится.